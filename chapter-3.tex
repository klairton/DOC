\chapter{Modelos com Porporção entre Operações}\label{chapter:JWIGFELF}

Os problemas de distância entre genomas podem utilizar uma abordagem \emph{não ponderada}, ou seja, cada evento de rearranjo utilizado para transformar o genoma de origem no genoma alvo contribui em uma unidade para a distância. Essa abordagem tem como característica que cada tipo de evento de rearranjo, pertencente ao modelo de rearranjo adotado, possui a mesma probabilidade de ocorrer em um cenário evolutivo. Outra abordagem que surgiu para possibilitar uma contribuição diferente para cada evento de rearranjo é chamada de \emph{ponderada}. Nesse abordagem, cada tipo de evento de rearranjo possui um peso associado que é contabilizado na distância evolutiva entre os genomas. A abordagem ponderada geralmente é utilizada para mapear um cenário em que queremos que determinado eventos de rearrajo tenham uma possibilidade maior de ocorrer do que outros. Para isso, basta atribuir um peso menor nos eventos de rearranjo que esperados que ocorram mais. Esses pesos podem ser atribuídos com base em observações empíricas de determinados organismos ou através de análises realizadas especificamente para esse objetivo~\cite{2008-bader-etal,2001-eriksen}. 

Os eventos de rearranjo de reversão e transposição são dois dos eventos mais estudados na literatura~\cite{2002-berman-etal,2006-elias-hartman,2022-silva-etal}. Considerando uma representação clássica e uma abordagem não ponderada, temos o problema de Ordenção de Permutações por Reversões e Transposições (\SbRT), sendo que o problema possui a variação com e sem sinais. Ambas as variações pertencem à classe NP-difícil de problemas~\cite{2019b-oliveira-etal}, para a variação com sinais do problema existe um algoritmo de aproximação com fator 2~\cite{1998-walter-etal}. Para a variação sem sinais, existe um algoritmo de aproximação com fator $2k$~\cite{2008-rahman-etal}, onde $k$~\cite{2013-chen} é o fator de aproximação do algoritmo utilizado para a decomposição de ciclos do Grafo de Ciclos~\cite{1999-caprara}.

Considerando um abordagem poderada, temos o problema de Ordenção de Permutações por Reversões e Transposições Ponderadas (\SbWRT) na variação com e sem sinais. In 2002, Eriksen~\cite{2002-eriksen} apresentou um algoritmo com factor de aproximação $7/6$ para a variação com sinais do problema utilizando os pesos $1$ e $2$ para os eventos de reversão e transposição, respectivamente. Oliveira \textit{et al.}\cite{2019a-oliveira-etal} desenvolveram um algoritmo de aproximação com fator $1.5$ para a variação com sinais do problema \SbWRT{} utilizando os pesos $2$ e $3$ para os eventos de reversão e transposição, respectivamente. Além disso, os autores mostraram que as variações com e sem sinais do problema \SbWRT{} pertencem à classe NP-difícil quando a razão entre os pesos dos eventos de transposição e reversão é maior ou igual a $1.5$.  

Em 2007, Bader e Ohlebusch~\cite{2007-bader-ohlebusch} apresentaram o problema de Ordenção de Permutações por Reversões, Transposições e Transposições Inversa Ponderadas (\SbWRTIT). A transposição inversa é um evento similar ao evento de transposição, mas com um dos segmentos adjacentes afetados sendo invertido. Para a variação com sinais do problema os autores apresentaram um algoritmo de aproximação com fator $1.5$ utilizando o peso $1$ para o evento de reversão e o mesmo peso, no intervalo $[1..2]$, para os eventos de transposição e transposição inversa. Em 2020, Alexandrino \textit{et al.}\cite{2020b-alexandrino-etal} mostraram que as variações com e sem sinais do problema \SbWRTIT{} pertencem à classe NP-difícil quando os eventos de transposição e transposição inversa possuem o mesmo peso e a razão entre os pesos dos eventos de transposição e reversão é maior ou igual a $1.5$.

A abordagem ponderada possui vantagens em comparação com a abordagem não ponderada quando queremos mapear um cenário evolutivo dando mais prioridade para determinados tipos de eventos de rearranjo. Entretanto, ela não garantem que os rearranjos de menor custo, que são supostamente os mais frequentes em um cenário evolutivo, serão os mais utilizados pelos algoritmos. Para contornar esse ponto, propomos e investigamos o problema de Ordenção de Permutações por Reversões e Transposições com Restrição de Proporção (\SbPRT) em instâncias clássicas com e sem sinais. Neste cenário, buscamos uma sequência de reversões e transposições $S$ capaz de transformar o genoma de origem no genoma alvo com uma restrição adicional na qual a relação entre o número de reversões e o tamanho da sequência $S$ deve ser maior ou igual a um determinado parâmetro $k \in [0..1]$. 

Observe que tanto as abordagens ponderada e proporcional tentam incorporar no modelo a frequência na qual os eventos de rearranjo afetam o genoma de um determinado organismo. É importante notar que, do ponto de vista biológico, a frequência e o conjunto de eventos de rearranjo podem variar dependendo do organismo considerado. De um ponto de vista teórico, as abordagens possuem objetivos diferentes, apesar de compartilharem características comuns. Uma característica que difere da abordagem de proporção é que uma vez conhecida a frequência na qual os eventos afetam o genoma, a proporção pode ser facilmente derivada dessa informação, enquanto que na abordagem ponderada o peso associado a cada tipo de evento precisa ser ajustado e validado através de testes experimentais.

O Exemplo~\ref{example:DFGJNHTP} mostra uma solução ótimo $S$ para a instância clássica com sinais $(({+0}~{-1}~{+4}~{-8}~{+3}~{+5}~{+2}~{-7}~{-6}~{+9}),({+0}~{+1}~{+2}~{+3}~{+4}~{+5}~{+6}~{+7}~{+8}~{+9}))$ considerando os problemas \SbRT{} e \SbWRT{} (utilizando os pesos $2$ e $3$ para os eventos de reversão e transposição, respectivamente). Note que metade dos eventos de rearranjo de $S$ são reversões e a outra metade transposições, mesmo utilizando um custo maior para o evento de transposição.

\input{examples/DFGJNHTP}

O Exemplo~\ref{example:MODRXOJQ} mostra uma solução ótima $S'$ para a mesma instância clássica com sinais apresentada no Exemplo~\ref{example:DFGJNHTP} considerando o problem \SbPRT{} e adotando um valor de $k = 0.6$, ou seja, pelo menos 60\% dos eventos de rearranjo em $S'$ devem ser reversões. Quando comparamos com o Exemplo~\ref{example:DFGJNHTP}, podemos perceber que $S'$ possui apenas um evento a mais que $S$, mas a proporção mínima de reversões em relação ao tamanho da sequência $S'$ é garantida.

\input{examples/MODRXOJQ}

Dada uma sequência de eventos de rearranjo $S$, denotamos por $|S|$ o tamanho da sequência $S$, ou seja, a quantidade de eventos em $S$. Além disso, denotamos por $|S_{\rho}|$ a quantidade de eventos de reversão em $S$. A seguir, descrevemos formalmente o problema de Ordenção de Permutações por Reversões e Transposições com Restrição de Proporção.

\begin{task}
  \problemtitle{Ordenção de Permutações por Reversões e Transposições com Restrição de Proporção (\SbPRT)}
  \probleminput{Uma instância clássica com ou sem sinais $\mathcal{I}=(\pi,\iota)$ e um número racional $k \in [0..1]$.}
  \problemtask{Com base no modelo de rearranjo $\mathcal{M}=\{\rho,\tau\}$, determinar uma sequência de eventos de rearranjo $S$ de tamanho mínimo capaz de transformar $\pi$ em $\iota$, tal que $\frac{|S_{\rho}|}{|S|} \ge k$.}
\end{task}

Dada uma instância clássica com ou sem sinais $\mathcal{I}=(\pi,\iota)$ e um número racional $k \in [0..1]$, a \emph{distância de propoção} entre $\pi$ e $\iota$, denotada por $dp_{k}(\mathcal{I})$, é o tamanho da menor sequências de eventos de rearranjo $S$, tal que todo evento de $S$ pertence ao modelo $\mathcal{M}=\{\rho,\tau\}$, $\pi \cdot S = \iota$ e $\frac{|S_{\rho}|}{|S|} \ge k$. Por praticidade, nesse capítulo iremos nos referir a um breakpoint clássico simplesmente como um breakpoint.

Nesse capítulo, provaremos que o problema \SbPRT{} pertence à classe NP-difícil em instâncias clássicas sem sinais para qualquer valor de $k$. Em instâncias clássicas com sinais mostraremos que existe um algoritmo exato polinomial para o problema quando $k=1$ e provaremos que o problema pertence à classe NP-difícil quando $k < 1$. Para as variações com e sem sinais do problema \SbPRT{} apresentaremos algoritmos de aproximação com fatores $3 - \frac{3k}{2}$ e $3-k$, respectivamente. Além disso, apresentaremos um algoritmo de aproximação assintótico com um fator teórico melhor para instâncias clássicas com sinais. Por fim, realizaremos experimentos comparando o desempenho práticos dos algoritmo propostos.

Estes resultados foram publicados em 2021 na revista \emph{Journal of Bioinformatics and Computational Biology}~\cite{2021a-brito-etal}.

% ------------------------------------------------------------------ %
\section{Limitantes Inferiores}
% ------------------------------------------------------------------ %

Nessa seção, apresentamos limitantes inferiores para as variações com e sem sinais do problema \SbPRT{}.

\begin{lemma}[Kececioglu e Sankoff~\cite{1995-kececioglu-sankoff}]\label{lemma:QIRAVPQT}
Dada uma instância clássica sem sinais $\mathcal{I} = (\pi,\iota)$, para qualquer reversão $\rho$ temos que $\Delta b_1(\mathcal{I}, S = (\rho)) \ge -2$.
\end{lemma}

\begin{lemma}[Walter \textit{et al.}~\cite{1998-walter-etal}]\label{lemma:NJATEDCC}
Dada uma instância clássica sem sinais $\mathcal{I} = (\pi,\iota)$, para qualquer transposição $\tau$ temos que $\Delta b_1(\mathcal{I}, S = (\tau)) \ge -3$.
\end{lemma}

\begin{lemma}\label{lemma:JYYZBREC}
Dada uma instância clássica sem sinais $\mathcal{I} = (\pi,\iota)$ para o problema $\SbPRT{}$ considerando a proporção $k \in [0..1]$ e seja $S$ uma sequência ótima de eventos de rearranjo para o problema. O número de breakpoints tipo um removidos por cada evento de $S$, em média, é menor ou igual a $3-k$.
\end{lemma}
\begin{proof}
Como $S$ é uma sequência ótima para a instância $\mathcal{I}$ com base na proporção $k$, temos que pelo menos $|S|k$ eventos presentes em $S$ são reversões. Pelos lemas~\ref{lemma:QIRAVPQT} e \ref{lemma:NJATEDCC}, temos que uma reversão pode remover até dois breakpoints tipo um enquanto uma transposição pode remover até três. Seja $\phi b(S)$ o número médio de breakpoints tipo um removidos por um evento de $S$, temos que:
$$\phi b(S) \le \frac{(2 |S| k) + (3 |S| (1 - k))}{|S|} = 2k + 3(1 - k) = 3 - k.$$ 
\end{proof}

\begin{lemma}[Hannenhalli e Pevzner~\cite{1999-hannenhalli-pevzner}]\label{lemma:MYFTFTWE}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$, para qualquer reversão $\rho$ temos que $\Delta b_2(\mathcal{I}, S = (\rho)) \ge -2$.
\end{lemma}

\begin{lemma}\label{lemma:AKEQRMOY}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$, para qualquer transposição $\tau$ temos que $\Delta b_2(\mathcal{I}, S = (\tau)) \ge -3$.
\end{lemma}
\begin{proof}
Note que uma transposição pode afetar no máximo três breakpoints tipo dois de $\mathcal{I}$. Logo, no melhor cenário, os três breakpoints são removidos e o lema segue.
\end{proof}

\begin{lemma}\label{lemma:ZZLNPRWJ}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$ para o problema $\SbPRT{}$ considerando a proporção $k \in [0..1]$ e seja $S$ uma sequência ótima de eventos de rearranjo para o problema. O número de breakpoints tipo dois removidos por cada evento de $S$, em média, é menor ou igual a $3-k$.
\end{lemma}
\begin{proof}
A prova é similar a descrita no Lema~\ref{lemma:JYYZBREC}, mas considerando os lemas~\ref{lemma:MYFTFTWE} e \ref{lemma:AKEQRMOY}.
\end{proof}

\begin{lemma}[Hannenhalli e Pevzner~\cite{1999-hannenhalli-pevzner}]\label{lemma:WMUBEYJS}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$, para qualquer reversão $\rho$ temos que $\Delta c(G(\mathcal{I}), S = (\rho)) \le 1$.
\end{lemma}

\begin{lemma}[Bafna e Pevzner~\cite{1995b-bafna-pevzner}; Walter \textit{et al.}~\cite{1998-walter-etal}]\label{lemma:WITSEXYZ}
Dada uma instância clássica com ou sem sinais $\mathcal{I} = (\pi,\iota)$, para qualquer transposição $\tau$ temos que $\Delta c(G(\mathcal{I}), S = (\tau)) \le 2$.
\end{lemma}

\begin{lemma}\label{lemma:IMSCPWKN}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$ para o problema $\SbPRT{}$ considerando a proporção $k \in [0..1]$ e seja $S$ uma sequência ótima de eventos de rearranjo para o problema. A variação no número de ciclos para cada evento de $S$, em média, é menor ou igual a $2-k$.
\end{lemma}
\begin{proof}
Como $S$ é uma sequência ótima para a instância $\mathcal{I}$ com base na proporção $k$, temos que pelo menos $|S|k$ eventos presentes em $S$ são reversões. Pelos lemas~\ref{lemma:WMUBEYJS} e \ref{lemma:WITSEXYZ}, temos que uma reversão pode criar até um novo ciclo enquanto uma transposição pode criar até dois. Seja $\phi c(S)$ o número médio de ciclos criados por um evento de $S$, temos que:
$$\phi c(S) \leq \frac{(1 |S| k) + (2 |S| (1 - k))}{|S|} = 1k + 2(1 - k) = 2 - k.$$
\end{proof}

\begin{theorem}\label{theorem:KJXGKJIP}
Dada uma instância clássica sem sinais $\mathcal{I} = (\pi,\iota)$ para o problema $\SbPRT{}$ e uma proporção $k \in [0..1]$, temos que $dp_{k}(\mathcal{I}) \ge \frac{b_1(\mathcal{I})}{3-k}$.
\end{theorem}
\begin{proof}
Como $b_1(\mathcal{I})$ breakpoints tipo um devem ser removidos para transformar $\pi$ em $\iota$ e, pelo Lema~\ref{lemma:JYYZBREC}, até $3-k$ breakpoints tipo um são removidos, em média, por cada operação de uma sequência ótima para o problema. Logo, o teorema segue.
\end{proof}

\begin{theorem}\label{theorem:ABGZQHIL}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$ para o problema $\SbPRT{}$ e uma proporção $k \in [0..1]$, temos que $dp_{k}(\mathcal{I}) \ge \frac{b_2(\mathcal{I})}{3-k}$.
\end{theorem}
\begin{proof}
A prova é similar a descrita no Teorema~\ref{theorem:KJXGKJIP}, mas considerando o número de breakpoints tipo dois em $\mathcal{I}$ e o Lema~\ref{lemma:ZZLNPRWJ}.
\end{proof}

\begin{theorem}\label{theorem:WSTPPSMD}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$ para o problema $\SbPRT{}$ e uma proporção $k \in [0..1]$, temos que $dp_{k}(\mathcal{I}) \ge \frac{n + 1 - c(G(\mathcal{I}))}{2-k}$.
\end{theorem}
\begin{proof}
Note que, pela Obervação~\ref{remark:OYRVGHTB}, $n+1 - c(G(\mathcal{I}))$ novos ciclos precisam ser criados para transformar $\pi$ em $\iota$. Pelo Lema~\ref{lemma:IMSCPWKN}, até $2-k$ novos ciclos são criados, em média, por cada operação de uma sequência ótima para o problema. Logo, o teorema segue.
\end{proof}

% ------------------------------------------------------------------ %
\section{Análise de Complexidade}
% ------------------------------------------------------------------ %

Nessa seção, apresentamos uma análise de complexidade do problema \SbPRT{} em instâncias clássicas com e sem sinais para todos os possível valores de $k$. A seguir descrevemos formalmente a versão de decisão do problema \SbPRT{}.

\begin{decision}
  \problemtitle{\SbPRT (Versão de Decisão)}
  \probleminput{Uma instância clássica com ou sem sinais $\mathcal{I}=(\pi,\iota)$, um número racional $k \in [0..1]$ e um número natural $t$.}
  \problemquestion{Existe uma sequência de eventos de rearranjo $S$, com base no modelo de rearranjo $\mathcal{M}=\{\rho,\tau\}$, capaz de transformar $\pi$ em $\iota$, tal que $\frac{|S_{\rho}|}{|S|} \ge k$ e $|S| = t$?}
\end{decision}

Note que para o problema \SbPRT{} é possível fornecer como entrada diferentes valores para $k$. Entretanto, quando utilizamos o valor de $k=0$ obtemos o problema \SbRT{}, uma vez que estipulamos que em uma solução não é necessário obter uma porcentagem mínima de eventos de reversão em comparação ao tamanho da sequência de eventos de rearranjo. Por outro lado, quando adotamos o valor de $k=1$, obtemos o problema de Ordenação de Permutações por Reversões (\SbR{}). Note que, nesse caso, toda solução para o problema deve ser composta exclusivamente por eventos de reversão. Com base nessa característica do problema obtemos os seguintes lemmas.

\begin{lemma}
O problema \SbPRT{} em instâncias clássicas com sinais pertence à classe NP-difícil quando $k=1$ e existe um algoritmo exato polinomial quando $k=0$.
\end{lemma}
\begin{proof}
Quando $k=0$ o problema \SbPRT{} em instâncias clássicas com sinais torna-se a variação com sinais do problema \SbRT{}, que é NP-difícil~\cite{2019b-oliveira-etal}. Por outro lado, quando $k=1$ o problema \SbPRT{} em instâncias clássicas com sinais torna-se a variação com sinais do problema \SbR{}, que possui um algoritmo exato polinomial~\cite{1999-hannenhalli-pevzner}.
\end{proof}

\begin{lemma}
O problema \SbPRT{} em instâncias clássicas sem sinais pertence à classe NP-difícil quando $k \in \{0,1\}$.
\end{lemma}
\begin{proof}
Quando $k=0$ e $k=1$ o problema \SbPRT{} em instâncias clássicas sem sinais torna-se a variação sem sinais dos problemas \SbRT{} e \SbR{}, respectivamente. Ambos os problemas pertencem à classe NP-difícil~\cite{2019b-oliveira-etal,1999-caprara}.
\end{proof}

A seguir investigamos a complexidade do problema \SbPRT{} quando $k$ pertence ao intervalo $(0..1)$. Para isso, apresentamos definições que serão utilizadas para provar a complexidade do problema para esse intervalo de valores de $k$. As transformações de \emph{duplicação}, \emph{orientação}, \emph{extensão bridge} e \emph{extensão gadget} descritas a seguir utilizam uma representação clássica de um genoma na sua forma não estendida. Caso a representação esteja na forma estendida, os elementos $\pi_0$ e $\pi_{n+1}$ são ignorados, a transformação é aplicada e a nova representação clássica resultante é então estendida.

\begin{definition}
Dada uma representação clássica sem sinais $\pi$ de tamanho $n$, a \emph{duplicação} cria uma representação clássica sem sinais $\pi'$ de tamanho $2n$ de forma que cada elemento $\pi_i \in \pi$ é mapeado em dois novos valores, com $\pi'_{2i-1} = 2\pi_i-1$ e $\pi'_{2i} = 2\pi_i$, para $i \in [1..n]$.
\end{definition}

O Exemplo~\ref{example:QJCKPQSS} mostra o transformação de duplicação sendo aplicado na representação clássica sem sinais $\pi=(4~1~5~3~2)$.

\input{examples/QJCKPQSS}

\begin{definition}
Dada uma representação clássica sem sinais $\pi$ de tamanho $n$, a \emph{orientação} cria uma representação clássica com sinais $\pi'$ também de tamanho $n$ de forma que $\pi'_{i} = +\pi_i$, para $i \in [1..n]$.
\end{definition}

O Exemplo~\ref{example:GUELXUJE} mostra a transformação de orientação sendo aplicado na representação clássica sem sinais $\pi=(4~1~5~3~2)$.

\input{examples/GUELXUJE}

\begin{definition}
Dada uma representação clássica com ou sem sinais $\pi$ de tamanho $n$, a \emph{extensão bridge} cria uma representação clássica $\pi'$ de tamanho $n + 3$. Caso $\pi$ seja uma representação com sinais, $\pi'$ é gerado da seguinte forma: (i) $\pi'_{i} = \pi_i$ e (ii) $\pi'_{n+j} = +(n{+j})$, para $i \in [1..n]$ e $j \in [1..3]$. Caso contrário, $\pi'$ é gerado da seguinte forma: (i) $\pi'_{i} = \pi_i$ e (ii) $\pi'_{n+j} = n{+j}$, para $i \in [1..n]$ e $j \in [1..3]$.
\end{definition}

O Exemplo~\ref{example:AWNIOTEZ} mostra a transformação de extensão bridge sendo aplicada na representação clássica com sinais $\pi=({+4}~{+1}~{+5}~{-3}~{-2})$.

\input{examples/AWNIOTEZ}

O Exemplo~\ref{example:BYQQHUAS} mostra a transformação de extensão bridge sendo aplicada na representação clássica sem sinais $\pi=(4~1~5~3~2)$.

\input{examples/BYQQHUAS}

\begin{definition}
Dada uma representação clássica com ou sem sinais $\pi$ de tamanho $n$, a \emph{extensão gadget} cria uma representação clássica $\pi'$ de tamanho $n + 6$. Caso $\pi$ seja uma representação com sinais, $\pi'$ é gerado da seguinte forma: (i) $\pi'_{i} = \pi_i$; (ii) $\pi'_j = -(n+4-j)$; (iii) $\pi'_{n+k} = +(n{+k})$, para $i \in [1..n]$, $j \in [1..3]$ e $k \in [4..6]$. Caso contrário, $\pi'$ é gerado da seguinte forma: (i) $\pi'_{i} = \pi_i$; (ii) $\pi'_j = n+4-j$; (iii) $\pi'_{n+k} = n{+k}$, para $i \in [1..n]$, $j \in [1..3]$ e $k \in [4..6]$.
\end{definition}

O Exemplo~\ref{example:TCTQPMWV} mostra a transformação de extensão gadget sendo aplicada na representação clássica com sinais $\pi=({+4}~{+1}~{+5}~{-3}~{-2})$.

\input{examples/TCTQPMWV}

O Exemplo~\ref{example:ZMGTJRFE} mostra a transformação de extensão gadget sendo aplicada na representação clássica sem sinais $\pi=(4~1~5~3~2)$.

\input{examples/ZMGTJRFE}

A seguir descrevemos formalmente a versão de decisão do problema de Ordenação de Permutações por 3-Transposições (\textbf{B3T}).

\begin{decision}
  \problemtitle{\textbf{B3T} (Versão de Decisão)}
  \probleminput{Uma instância clássica sem sinais $\mathcal{I}=(\pi,\iota)$, tal que $b_2(\mathcal{I}) = 3s$ e $s$ é um número natural não nulo.}
  \problemquestion{Existe uma sequência de eventos de rearranjo $S$, com base no modelo de rearranjo $\mathcal{M}=\{\tau\}$, capaz de transformar $\pi$ em $\iota$, tal que $|S| = \frac{b_2(\mathcal{I})}{3}$?}
\end{decision}

Bulteau e coautores~\cite{2012-bulteau-etal} provaram que o problem \textbf{B3T} pertence à classe NP-difícil. Utilizaremos uma redução do problema \textbf{B3T} para provar que o problema \SbPRT{} é NP-difícil quando $k$ pertence ao intervalo $(0..1)$.

\begin{lemma}[Oliveira~\textit{et al.}~\cite{2019b-oliveira-etal}]\label{lemma:CWNRJAPM}
Se uma instância clássica com sinais $\mathcal{I}=(\pi,\iota)$ possui apenas strips positivas, para qualquer reversão $\rho$ temos que $\Delta b_2(\mathcal{I}, S=(\rho)) \ge 0$.
\end{lemma}

\begin{theorem}\label{theorem:NSWQYFLG}
O problema \SbPRT{} em instâncias clássicas com sinais pertence à classe NP-difícil quando $k \in (0..1)$.
\end{theorem}
\begin{proof}
Dada uma instância clássica sem sinais $\mathcal{I}=(\pi,\iota)$ para o problema \textbf{B3T}, definimos $\ell = \frac{b_2(\mathcal{I})}{3} \ge 1$. Criamos uma instância clássica com sinais $\mathcal{I'}=(\pi',\iota')$ para o problema \SbPRT{} da seguinte maneira:

\begin{enumerate}
  \item Seja $\sigma$ uma representação clássica com sinais de tamanho $n+3$ obtida através do processo de orientação aplicado em $\pi$ e seguido da extenção bridge.
  \item Seja $k$ um número racional no intervalo $(0..1)$, definimos $p = \lceil\frac{\ell k}{1-k}\rceil \ge 1$, ou seja, $p$ é o menor número inteiro tal que $\frac{p}{p+\ell} \ge k$.
  \item Seja $\pi'$ uma representação clássica com sinais de tamanho $n+3+6p$ obtida através da aplicação consecutiva de $p$ extensões gadget em $\sigma$.
  \item Seja $\iota'$ uma representação clássica com sinais de tamanho $n+3+6p$. Caso $\pi$ esteja na sua forma estendida, $\iota'_i = +i$ para $i \in [1..(n+3+6p)]$. Caso contrário,  $\iota'_i = +i$ para $i \in [0..(n+3+6p-1)]$.
\end{enumerate}

O Exemplo~\ref{example:NDFPEMFC} mostra o processo de criação de uma instância clássica com sinais $\mathcal{I'}=(\pi',\iota')$ para o problema \SbPRT{} a partir de uma instância clássica sem sinais $\mathcal{I}=(\pi,\iota)$ para o problema \textbf{B3T}. Note que em ambas as instâncias os genomas de origem e alvo são representados na forma estendida. Além disso, é importante lembrar que o problema \textbf{B3T} e a variação com sinais do problema \SbPRT{} utilizam breakpoints tipo dois. Note que a transformação de orientação preserva o número de breakpoints tipo dois, já que adicionamos apenas um sinal positivo aos elementos da permutação. A extensão bridge também preserva o número breakpoints tipo dois, já que adiciona apenas três elementos consecutivos ao final da permutação. Por outro lado, cada extensão gadget adiciona dois novos breakpoints tipo dois (ou seja, as extremidades de cada strip negativa), então $b_2(\mathcal{I'}) = b_2(\mathcal{I}) +2p$.

Agora mostramos que a instância $\mathcal{I}$ do problema \textbf{B3T} é satisfeita se e somente se $dp_k(\mathcal{I'}) \le \ell+p$.

($\Rightarrow$) Suponha que existe uma sequência $S$ com $\ell$ transposições, tal que $\pi \cdot S = \iota$. Isso significa que cada transposição de $S$ remove exatamente três breakpoints tipo dois de $\mathcal{I}$. Considere a sequência $S'$ como sendo uma cópia de $S$ e incluindo $p$ reversões, de forma que cada reversão é aplicada sobre uma strip negativa de $\mathcal{I'}$. Como $\pi'_i = +\pi_i$ para $i \in [1..n]$, cada transposição de $S'$ também remove exatamente três breakpoints tipo dois, restando apenas $2p$ breakpoints tipo dois para serem removidos. Contúdo, cada reversão $\rho \in S'$ remove dois breakpoints tipo dois (criados pela extensão gadget). Logo, $|S'| = \ell+p$, $\pi' \cdot S' = \iota'$ e $\frac{|S_{\rho}'|}{|S'|}$.

($\Leftarrow$) Pelo Teorema~\ref{theorem:ABGZQHIL}, temos que $dp_k(\mathcal{I'}) \ge \frac{b_2(\mathcal{I'})}{3-k} = \frac{b_2(\mathcal{I})+2p}{3-k}$. Como temos por construção que $b_2(\mathcal{I}) = 3\ell$ e $\frac{p-1}{\ell+(p-1)} < k \leq \frac{p}{\ell+p}$, segue que $dp_k(\mathcal{I'}) > \frac{(\ell+p-1)(3\ell+2p)}{3\ell+2p-2}$. Além disso, $\ell \geq 1$ e $p \geq 1$, então $\frac{3\ell+2p}{3\ell+2p-2} > 1$ e $dp_k(\mathcal{I'}) > \ell+p-1$, o que resulta em $d_k(\mathcal{I'}) \ge \ell + p$. Suponha que existe uma sequência de eventos de rearranjo $S'$ de tamanho $\ell + p$, tal que $\pi' \cdot S' = \iota'$ e $\frac{|S_{\rho}'|}{|S'|} \ge k$.

Como $b_2(\mathcal{I'}) = 3\ell+2p$, então deve existir pelo menos $\ell$ transposições em $S'$ com cada uma removendo três breakpoints tipo dois. Caso contrário, $S'$ não seria capaz de transformar $\pi'$ em $\iota'$. Além disso, deve exitir no máximo $\ell$ transpositions in $S'$. Caso contrário, a proporção $\frac{|S_{\rho}'|}{|S'|}$ não seria satisfeita. Dessa forma, temos que existe $\ell$ transposições em $S'$ com cada uma removendo três breakpoints tipo dois. Logo, restam $|S'| - \ell = \ell+p - \ell = p$ reversões em $S'$, e cada reversão deve remover dois breakpoints tipo dois. Caso contrário, $S'$ não seria capaz de transformar $\pi'$ em $\iota'$.

Vamos definir três tipos de elementos em $\pi'$. Dizemos que um dado elemento $\pi'_i$ é (i) original se $i \in [1..n]$; (ii) transitório se $i \in [n{+1}..n{+3}]$; e (iii) estendido se $i > n{+3}$. Como os elementos originais e transitórios são todos positivos, as strips nas primeiras $n+3$ posições são todas positivas. Pelo Lemma~\ref{lemma:CWNRJAPM}, nenhuma reversão $\rho$ aplicada nesses elementos remove breakpoints tipo dois, e isto permanece verdadeiro enquanto as transposições afetam apenas os elementos originais.

Como não é aplicada nenhuma reversão aos elementos originais, os $3\ell$ breakpoints tipo dois $(\pi'_i,\pi'_{i+1})$, tal que pelo menos $\pi'_i$ é um elemento original, devem ser removidos por transposições. Dessa forma, $S'$ possui $\ell$ transposições $\tau^{(i,j,k)}$ de tal maneira que $1 \le i < j < k \le n+1$ (ou seja, as transposições afetam apenas os elementos originais). 

Os restantes eventos de rearranjo de $S'$, ou seja, as $p$ reversões, devem remover $2p$ breakpoints tipo dois $(\pi'_i,\pi'_{i+1})$, de tal forma que pelo menos $\pi'_{i+1}$ seja um elemento estendido (ou seja, $i \ge n+3$). A cada iteração, as únicas reversões que removem dois breakpoints tipo dois são aquelas aplicadas nas duas extremidades de uma strip negativa, implicando que cada reversão de $S'$ é aplicada em uma das $p$ strips negativas adicionadas pelas extensões gadget.

Perceba que $S'$ possui $\ell$ transposições que removem $3\ell$ breakpoints tipo dois $(\pi'_i,\pi'_{i+1})$, tal que $i \le n$. Seja $S$ uma sequência de transposições criada a partir das transposições de $S'$ mantendo a mesma ordem relativa. Como $\pi'_i = +\pi_i$ para $i \in [1..n]$, $\pi \cdot S = \iota$, e o teorema segue.
\end{proof}

\input{examples/NDFPEMFC}

\begin{lemma}[Oliveira~\textit{et al.}~\cite{2019b-oliveira-etal}]\label{lemma:PXXMRMWO}
Se uma instância clássica sem sinais $\mathcal{I}=(\pi,\iota)$ possui apenas strips crescentes, para qualquer reversão $\rho$ temos que $\Delta b_1(\mathcal{I}, S=(\rho)) \ge 0$.
\end{lemma}

\begin{theorem}\label{theorem:QMHEKDLW}
O problema \SbPRT{} em instâncias clássicas sem sinais pertence à classe NP-difícil quando $k \in (0..1)$.
\end{theorem}
\begin{proof}
Dada uma instância clássica sem sinais $\mathcal{I}=(\pi,\iota)$ para o problema \textbf{B3T}, definimos $\ell = \frac{b_2(\mathcal{I})}{3} \ge 1$. Criamos uma instância clássica com sinais $\mathcal{I'}=(\pi',\iota')$ para o problema \SbPRT{} da seguinte maneira:

\begin{enumerate}
  \item Seja $\sigma$ uma representação clássica sem sinais de tamanho $2n+3$ obtida através do processo de duplicação aplicado em $\pi$ e seguido da extenção bridge.
  \item Seja $k$ um número racional no intervalo $(0..1)$, definimos $p = \lceil\frac{\ell k}{1-k}\rceil \ge 1$, ou seja, $p$ é o menor número inteiro tal que $\frac{p}{p+\ell} \ge k$.
  \item Seja $\pi'$ uma representação clássica sem sinais de tamanho $2n+3+6p$ obtida através da aplicação consecutiva de $p$ extensões gadget em $\sigma$.
  \item Seja $\iota'$ uma representação clássica com sinais de tamanho $2n+3+6p$. Caso $\pi$ esteja na sua forma estendida, $\iota'_i = i$ para $i \in [1..(n+3+6p)]$. Caso contrário,  $\iota'_i = i$ para $i \in [0..(n+3+6p-1)]$.
\end{enumerate}

O Exemplo~\ref{example:QBULCCOI} mostra o processo de criação de uma instância clássica sem sinais $\mathcal{I'}=(\pi',\iota')$ para o problema \SbPRT{} a partir de uma instância clássica sem sinais $\mathcal{I}=(\pi,\iota)$ para o problema \textbf{B3T}. Note que em ambas as instâncias os genomas de origem e alvo são representados na forma estendida. Note que, exceto por $\sigma_0$, cada elemento em posições pares de $\sigma$ é igual ao elemento à sua esquerda mais um. Isto significa que (i) exceto para a primeira e última strip, qualquer outra strip em $\sigma$ deve ter pelo menos dois elementos, ou seja, não existem singletons, e (ii) cada strip de $\sigma$ é crescente. Estas observações também são válidas para as primeiras $2n+3$ posições de $\pi'$. Além disso, é importante lembrar que o problema \textbf{B3T} utiliza breakpoints tipo dois enquanto a variação sem sinais do problema \SbPRT{} utiliza breakpoints tipo um. Note que (i) para cada breakpoint tipo dois $(\pi_i,\pi_{i+1})$ de $\mathcal{I}$ existe um breakpoint tipo um $(\pi'_{2i},\pi'_{2i+1})$ em $\mathcal{I'}$ (criado durante a transformação de duplicação), (ii) os pares $(\pi'_{2i-1},\pi'_{2i})$ não são breakpoints tipo um, para $i \in [1..n]$ e (iii) os pares $(\pi'_{2n+j},\pi'_{2n+j+1})$ não são breakpoints tipo um, para $j \in [1..3]$. Por outro lado, cada extensão gadget adiciona dois novos breakpoints tipo um (ou seja, as extremidades de cada strip decrescente), então $b_2(\mathcal{I'}) = b_1(\mathcal{I}) +2p$.

Agora mostramos que a instância $\mathcal{I}$ do problema \textbf{B3T} é satisfeita se e somente se $dp_k(\mathcal{I'}) \le \ell+p$.

($\Rightarrow$) Suponha que existe uma sequência $S$ com $\ell$ transposições, tal que $\pi \cdot S = \iota$. Isso significa que cada transposição de $S$ remove exatamente três breakpoints tipo dois de $\mathcal{I}$. Considere a sequência $S'$ criada da seguinte forma: (i) para cada transposição $\tau^{(i,j,k)}$ de $S$, seguindo a ordem relativa, adicione em $S'$ a transposição $\tau^{(2i-1,2j-1,2k-1)}$; (ii) Em seguida, adicione $p$ reversões em $S'$, de forma que cada reversão é aplicada sobre uma strip decrescente de $\mathcal{I'}$. Note que cada transposição de $S$ remove três breakpoints tipo dois de $\mathcal{I}$. Como temos que para cada breakpoint tipo dois $(\pi_i,\pi_{i+1})$ em $\mathcal{I}$ temos um breakpoint tipo um $(\pi'_{2i},\pi'_{2i+1})$ em $\mathcal{I'}$, isso significa que cada transposição de $S'$ remove três breakpoints tipo um de $\mathcal{I'}$. Com isso, restam apenas $2p$ breakpoints tipo um para serem removidos em $\mathcal{I'}$. Contúdo, cada reversão $\rho \in S'$ remove dois breakpoints tipo dois (criados pela extensão gadget). Logo, $|S'| = \ell+p$, $\pi' \cdot S' = \iota'$ e $\frac{|S_{\rho}'|}{|S'|}$.

($\Leftarrow$) Pelo Teorema~\ref{theorem:KJXGKJIP}, temos que $dp_k(\mathcal{I'}) \ge \frac{b_1(\mathcal{I'})}{3-k} = \frac{b_2(\mathcal{I})+2p}{3-k}$. Como temos por construção que $b_2(\mathcal{I}) = 3\ell$ e $\frac{p-1}{\ell+(p-1)} < k \leq \frac{p}{\ell+p}$, segue que $dp_k(\mathcal{I'}) > \frac{(\ell+p-1)(3\ell+2p)}{3\ell+2p-2}$. Além disso, $\ell \geq 1$ e $p \geq 1$, então $\frac{3\ell+2p}{3\ell+2p-2} > 1$ e $dp_k(\mathcal{I'}) > \ell+p-1$, o que resulta em $d_k(\mathcal{I'}) \ge \ell + p$. Suponha que existe uma sequência de eventos de rearranjo $S'$ de tamanho $\ell + p$, tal que $\pi' \cdot S' = \iota'$ e $\frac{|S_{\rho}'|}{|S'|} \ge k$.

Como $b_1(\mathcal{I'}) = 3\ell+2p$, então deve existir pelo menos $\ell$ transposições em $S'$ com cada uma removendo três breakpoints tipo um. Caso contrário, $S'$ não seria capaz de transformar $\pi'$ em $\iota'$. Além disso, deve exitir no máximo $\ell$ transpositions in $S'$. Caso contrário, a proporção $\frac{|S_{\rho}'|}{|S'|}$ não seria satisfeita. Dessa forma, temos que existe $\ell$ transposições em $S'$ com cada uma removendo três breakpoints tipo um. Logo, restam $|S'| - \ell = \ell+p - \ell = p$ reversões em $S'$, e cada reversão deve remover dois breakpoints tipo um. Caso contrário, $S'$ não seria capaz de transformar $\pi'$ em $\iota'$.

Vamos definir três tipos de elementos em $\pi'$. Dizemos que um dado elemento $\pi'_i$ é (i) original se $i \in [1..2n]$; (ii) transitório se $i \in [2n{+1}..2n{+3}]$; e (iii) estendido se $i > 2n{+3}$. Como todos elementos originais e transitórios fazem parte de uma strip crescente, pelo Lemma~\ref{lemma:PXXMRMWO}, nenhuma reversão $\rho$ aplicada nesses elementos remove breakpoints tipo um, e isto permanece verdadeiro enquanto as transposições afetam breakpoints tipo um entre os elementos originais.

Como não é aplicada nenhuma reversão aos elementos originais, os $3\ell$ breakpoints tipo um $(\pi'_i,\pi'_{i+1})$, tal que pelo menos $\pi'_i$ é um elemento original, devem ser removidos por transposições. Dessa forma, $S'$ possui $\ell$ transposições $\tau^{(i,j,k)}$ de tal maneira que $1 \le i < j < k \le 2n+1$ (ou seja, as transposições afetam apenas os elementos originais). 

Os restantes eventos de rearranjo de $S'$, ou seja, as $p$ reversões, devem remover $2p$ breakpoints tipo um $(\pi'_i,\pi'_{i+1})$, de tal forma que pelo menos $\pi'_{i+1}$ seja um elemento estendido (ou seja, $i \ge 2n+3$). A cada iteração, as únicas reversões que removem dois breakpoints tipo um são aquelas aplicadas nas duas extremidades de uma strip decrescente, implicando que cada reversão de $S'$ é aplicada em uma das $p$ strips decrescentes adicionadas pelas extensões gadget.

Perceba que $S'$ possui $\ell$ transposições que removem $3\ell$ breakpoints tipo um $(\pi'_i,\pi'_{i+1})$, tal que $i \le 2n$. Seja $S$ uma sequência de transposições criada a partir das transposições de $S'$ da seguinte forma: (i) mantendo a mesma ordem relativa, para cada transposição $\tau^{(i,j,k)}$ de $S'$ adicione em $S$ a transposição $\tau^{(\frac{i+1}{2},\frac{j+1}{2},\frac{k+1}{2})}$. Como mapeamento feito reflete que cada transposição em $S$ remove três breakpoints tipo dois de $\mathcal{I}$, temos que $\pi \cdot S = \iota$, e o teorema segue.
\end{proof}

\input{examples/QBULCCOI}

% ------------------------------------------------------------------ %
\section{Algoritmos de Aproximação}
% ------------------------------------------------------------------ %

Nessa seção, apresentamos algoritmos de aproximação para as variações com e sem sinais do problema \SbPRT{}.

% ------------------------------------------------------------------ %
\subsection{Instâncias Clássicas sem Sinais}
% ------------------------------------------------------------------ %

Com base no conceito de breakpoint, apresentamos algoritmos de aproximação com fatores de $3-k$ para o problema \SbPRT{} em instâncias clássicas sem sinais.

\begin{lemma}[Kececioglu e Sankoff~\cite{1995-kececioglu-sankoff}]\label{lemma:PZWHPXFL}
Dada uma instância clássica sem sinais $\mathcal{I} = (\pi,\iota)$, é possível transformar $\pi$ em $\iota$ utilizando no máximo $b_1(\mathcal{I})$ reversões.
\end{lemma}

\begin{theorem}\label{theorem:FTRSGXOZ}
Existe um algoritmo de aproximação com fator $3-k$ para o problema \SbPRT{} em instâncias clássicas sem sinais e para uma proporção $k \in [0..1]$.
\end{theorem}
\begin{proof}
Pelo Lema~\ref{lemma:PZWHPXFL}, dada uma instância clássica sem sinais $\mathcal{I} = (\pi,\iota)$, é possível transformar $\pi$ em $\iota$ utilizando no máximo $b_1(\mathcal{I})$ reversões. Como somente reversões são utilizadas na sequência de rearranjo $S$, então a restrição $\frac{|S_{\rho}|}{|S|} \ge k$ nunca é violada. Além disso, pelo Teorema~\ref{theorem:KJXGKJIP}, temos que $dp_{k}(\mathcal{I}) \ge \frac{b_1(\mathcal{I})}{3-k}$. Logo, $\frac{b_1(\mathcal{I})}{\frac{b_1(\mathcal{I})}{3-k}} = 3-k$, e o teorema segue.
\end{proof}

Note que o algoritmo de aproximação resultante do Teorema~\ref{theorem:FTRSGXOZ} utiliza somente reversões. Para evitar que as soluções sejam compostas exclusivamente por reversões, nós propomos o Algoritmo~\ref{algorithm:INBRWKCH}. Esse algoritmo algoritmo também garante um fator de aproximação de $3-k$ para instâncias clássicas sem sinais do problem \SbPRT{} e para qualquer valor de $k$. Além disso, a propoção entre a quantidade de reversões e o tamanho da sequência de eventos de rearranjo fornecida pelo o algoritmo tende a ser um valor próximo de $k$.

\input{algorithms/INBRWKCH}

Observe que o Algoritmo~\ref{algorithm:INBRWKCH} aplica uma transposição $\tau$ se duas restrições forem satisfeitas: (i) $\frac{|S_{\rho}|}{|S| + 1} \ge k$, que garante que a sequência de eventos de rearranjo $S$ construída pelo algoritmo obedecerá à restrição do problema que $\frac{|S_{\rho}|}{|S|} \ge k$; e (ii) $\Delta b_1(\mathcal{I}, (\tau)) \le -1$, que garante que a sequência de ordenação conterá no máximo $b_1(\mathcal{I})$ operações, pois cada sequência de reversões adicionada da sequência $S$ remove, em média, um ou mais breakpoints tipo um por operação. Como o Algoritmo~\ref{algorithm:INBRWKCH} remove, em média, um ou mais breakpoints tipo um por iteração, ele garante que $\pi$ será transformada em $\iota$. Além disso, não mais do que $b_1(\mathcal{I})$ operações serão usadas para isso, mantendo o fator de aproximação de $3-k$. Como a transposição $\tau$ (linhas 3-5) e a sequência de no máximo duas reversões $S^{\prime}$ (linhas 6-9) podem ser encontradas em tempo linear, o tempo de execução do Algoritmo~\ref{algorithm:INBRWKCH} é $\mathcal{O}(n^2)$, considerando que $|S|~\le~b_1(\pi)~\le~{n + 1}$.

% ------------------------------------------------------------------ %
\subsection{Instâncias Clássicas com Sinais}
% ------------------------------------------------------------------ %

Com base na estrutura de grafo de ciclos clássico, apresentamos um algoritmo de aproximação com fator de $3-\frac{3k}{2}$ para o problema \SbPRT{} em instâncias clássicas com sinais.

\begin{lemma}\label{lemma:ZUHMXSRH}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$, existe uma sequência de reversões $S$ em que o número de ciclos criados por cada reversão, em média, é maior ou igual a $2/3$.
\end{lemma}
\begin{proof}
Se $G(\mathcal{I})$ possuir um ciclo divergente $C$, então existe uma reversão que quando aplicada em $C$ aumenta o número de ciclos em uma unidade (Teorema 5 de~\cite{1998-walter-etal}). Caso contrário, todos os ciclos não triviais devem ser convergentes. Isso significa que um dos seguintes cenários deve ocorrer obrigatoriamente~\cite{2019a-oliveira-etal}:
\begin{itemize}
  \item Existe em $G(\mathcal{I})$ um ciclo longo e orientado $C$ (Figura~\ref{figure:CQQWYGKH}, Caso 1);
  \item Existe em $G(\mathcal{I})$ um ciclo curto $C$ que os open gates são fechados por outro ciclo não trivial $D$ (Figura~\ref{figure:CQQWYGKH}, Caso 2);
  \item Existe em $G(\mathcal{I})$ um ciclo longo não orientado $C$ que os open gates são fechado por um ou mais ciclos não triviais (Figura~\ref{figure:CQQWYGKH}, Caso 3);
\end{itemize}

Se $G(\mathcal{I})$ possui um ciclo longo e orientado $C$, então podemos aplicar uma reversão em suas arestas pretas de maneira que $C$ é transformado em divergente. Como $C$ é um ciclo longo, então é possivel aplicar, pelo menos, duas reversões de forma que cada uma aumenta o número de ciclos em uma unidade (Figura~\ref{figure:CQQWYGKH}, Caso 1).

Se algum dos outros casos ocorrer, então podemos tornar o ciclo $C$ em divergente após aplicar uma reversão no(s) ciclo(s) que fecham os open gates de $C$. Se $C$ for um ciclo curto, então podemos aplicar uma reversão em suas arestas pretas quebrando-o em dois ciclos triviais, o que aumenta o número de ciclos em uma unidade. Como resultado da segunda reversão, o ciclo $D$ também passa a ser divergente, o que nos garante aplicar uma terceira reversão que aumenta o número de ciclos em uma unidade (Figura~\ref{figure:CQQWYGKH}, Caso 2). Se $C$ for um ciclo curto, então é possivel aplicar, pelo menos, duas reversões de forma que cada uma aumenta o número de ciclos em uma unidade (Figura~\ref{figure:CQQWYGKH}, Caso 3)

Nos três casos mencionados acima, aplicamos três reversões que aumentam em pelo menos duas unidades o número de ciclos, e o lema segue.
\end{proof}

\input{figures/CQQWYGKH}

\begin{lemma}\label{lemma:KZHQWACX}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$, é possível transforma $\pi$ em $\iota$ utilizando no máximo $\frac{3(n + 1 -c(G(\mathcal{I})))}{2}$ reversões.
\end{lemma}
\begin{proof}
O Lema~\ref{lemma:ZUHMXSRH} resulta em uma sequência de reversões que sempre aumenta o número de ciclos. Logo, podemos aplicarmos o Lema~\ref{lemma:ZUHMXSRH} até que $c(G(\mathcal{I}))$ seja igual a ${n+1}$. Consequentemente, $\pi$ será transformada em $\iota$. Além disso, cada sequência de reversões $S$ obtidas através do Lema~\ref{lemma:ZUHMXSRH} garante que o número de ciclos criados por cada reversão de $S$, em média, é maior ou igual a $2/3$. Logo, não mais do que $\frac{3(n + 1 -c(G(\mathcal{I})))}{2}$ reversões são utilizadas para transformar $\pi$ em $\iota$, e o lema segue.
\end{proof}

\begin{theorem}\label{theorem:HYRUPXPH}
Existe um algoritmo de aproximação com fator $3-\frac{3k}{2}$ para o problema \SbPRT{} em instâncias clássicas com sinais e para uma proporção $k \in [0..1]$.
\end{theorem}
\begin{proof}
Pelo Lema~\ref{lemma:KZHQWACX}, dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$, é possível transformar $\pi$ em $\iota$ utilizando no máximo $\frac{3(n + 1 -c(G(\mathcal{I})))}{2}$ reversões. Como somente reversões são utilizadas na sequência de rearranjo $S$, então a restrição $\frac{|S_{\rho}|}{|S|} \ge k$ nunca é violada. Além disso, pelo Teorema~\ref{theorem:WSTPPSMD}, temos que $dp_{k}(\mathcal{I}) \ge \frac{n + 1 - c(G(\mathcal{I}))}{2-k}$. Logo,
$$\frac{\frac{3(n + 1 - c(G(\mathcal{I})))}{2}}{\frac{n + 1 - c(G(\mathcal{I}))}{2-k}} = 3-\frac{3k}{2}.$$
\end{proof}


Note que o algoritmo de aproximação resultante do Teorema~\ref{theorem:HYRUPXPH} aplica somente reversões. Para evitar que as soluções sejam compostas exclusivamente por reversões, nós propomos o Algoritmo~\ref{algorithm:TNMWZNZU}. Esse algoritmo algoritmo também garante um fator de aproximação de $3-\frac{3k}{2}$ para instâncias clássicas com sinais do problem \SbPRT{} e para qualquer valor de $k$.

\input{algorithms/TNMWZNZU}

Observe que o Algoritmo~\ref{algorithm:TNMWZNZU} aplica uma transposição $\tau$ se duas restrições forem satisfeitas: (i) $\frac{|S_{\rho}|}{|S| + 1} \ge k$, que garante que a sequência de eventos de rearranjo $S$ construída pelo algoritmo obedecerá à restrição do problema que $\frac{|S_{\rho}|}{|S|} \ge k$; e (ii) $\Delta c(G(\mathcal{I}), (\tau)) \ge 1$, que garante que a sequência de ordenação conterá no máximo $\frac{3(n + 1 -c(G(\mathcal{I})))}{2}$ operações, pois cada sequência de reversões adicionada da sequência $S$ aumenta, em média, o número de ciclos em pelo menos $2/3$ unidades. Dessa forma, o algoritmo garante o fator de aproximação de $3-\frac{3k}{2}$. A transposição $\tau$ (linhas 3-5) pode ser encontrada em tempo linear, já a sequência de no máximo três reversões $S^{\prime}$ (linhas 6-9) pode ser encontradas em tempo $\mathcal{O}(n^2)$. Com isso, o tempo de execução do Algoritmo~\ref{algorithm:TNMWZNZU} é $\mathcal{O}(n^3)$, considerando que $|S| \le \frac{3(n + 1 -c(G(\mathcal{I})))}{2} \le \frac{3({n+1})}{2}$.

% ------------------------------------------------------------------ %
\subsubsection{Algoritmo de Aproximação Assintótica}
% ------------------------------------------------------------------ %

Nessa seção, apresentamos um algoritmo de aproximação assintótica com fator de $\frac{2-k}{1-k/3}$ para o problema \SbPRT{} em instâncias clássicas com sinais.

\begin{definition}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$, seja $\mathcal{A}_\rho$ o algoritmo descrito no Teorema~\ref{theorem:HYRUPXPH} que transforma $\pi$ em $\iota$ utilizando no máximo $\frac{3(n + 1 -c(G(\mathcal{I})))}{2}$ reversões. Denotamos por $\mathcal{A}_\rho(\mathcal{I})$ a sequência de reversões obtidas através de $\mathcal{A}_\rho$ e que transforma $\pi$ em $\iota$.
\end{definition}

\begin{remark}[Oliveira \textit{et al.}~\cite{2019a-oliveira-etal}]\label{remark:DNLEDNKT}
Dada uma representação clássica $\pi$, uma transposição $\tau^{(i,j,k)}$ pode ser reproduzida por uma sequência de três reversões consecutivas $S=(\rho^{(i,{j-1})},\rho^{(j,{k-1})},\rho^{(i,{k-1})})$, ou seja, $\pi \cdot \tau^{(i,j,k)} = \pi \cdot S$. 
\end{remark}

Agora considere o Algoritmo~\ref{algorithm:NTMUPIXY}. Note que podemos fazer uma análise considerando quatro sub-rotinas: i)  executar o algoritmo  $\mathcal{A}_\rho$ (linhas 2 e 12, tempo de execução $\mathcal{O}(n^3)$), ii) encontrar um ciclo divergente em $G(\mathcal{I})$ e determinar os parâmetros da reversão $\rho$ que aumenta o número de ciclos em uma unidade (linhas 3-6, em tempo linear), iii) determinar uma sequência de no máximo duas transposições que aumenta o número de ciclos em duas unidades (linhas 7-10, tempo de execução $\mathcal{O}(n^2)$) e iv) substituir até duas transposições de $S$ por uma sequência equivalente de reversões (linhas 13-14, tempo constante). Considerando que $|S| \le {n + 1}$, o tempo de execução de Algoritmo~\ref{algorithm:NTMUPIXY} é $\mathcal{O}(n^4)$.

\input{algorithms/NTMUPIXY}

\begin{lemma}\label{lemma:THMUHLVK}
Dada uma instância clássica com sinais $\mathcal{I} = (\pi,\iota)$ e um valor $k \in [0..1]$, o Algoritmo~\ref{algorithm:NTMUPIXY} fornece uma sequência de operações $S$ com no máximo $(n+1-c(G(\mathcal{I}))) / (1-k/3) + 4$ operações de reversões e transposições tal que $\pi \cdot S = \iota$ e $\frac{|S_{\rho}|}{|S|} \ge k$. 
\end{lemma}
\begin{proof}
Note que a sequência forneceida pelo algoritmo $\mathcal{A}_\rho$ (linha 12) trasforma $\pi$ em $\iota$. Consequentemente, o Algoritmo~\ref{algorithm:NTMUPIXY} também transforma $\pi$ em $\iota$.
Seja $S$ a sequência de operações gerada pelo Algoritmo~\ref{algorithm:NTMUPIXY} sem considerar a substituição de transposições por reversões feita na linha 14. Seja $S'$ a subsequência de $S$ criada durante o laço de repetição das linha 2 até 10. Note que, em média, cada operação em $S'$ aumenta o número de ciclos em pelo menos uma unidade. Além disso, em média, cada operação em $S \setminus S'$ (ou seja, as reversões utilizadas pelo algoritmo $\mathcal{A}_\rho$ na linha 12) aumenta o número de ciclos em pelo menos $2/3$ unidades. Pela condição na linha 2, temos que $|S'| \ge (1-k) |S|$. Além disso, em média, cada operação de $S$ aumenta o número de ciclos em pelo menos $\frac{(1-k)|S| + k|S|2/3}{|S|} = 1 - k/3$. Como para transformar $\pi$ em $\iota$ é necessário aumentar o número de ciclos em $n+1-c(G(\mathcal{I}))$ unidades, temos que $|S| \le \frac{n+1-c(G(\mathcal{I}))}{1-k/3}$. Note que a sequência $S$ pode não satisfazer a restrição $\frac{|S_{\rho}|}{|S|} \ge k$. Caso isso ocorra, sabemos que o Algoritmo~\ref{algorithm:NTMUPIXY} adiciona transposições em $S$ somente enquanto a condição da linha 2 for satisfeita e que, no máximo, duas transposições são adicionadas por iteração. No pior caso, garantimos que $\frac{|S_{\rho}|}{|S|} \ge k$ subtituindo até duas transposições de $S$ por seis reversões. Logo, $|S| \le \frac{n+1-c(G(\mathcal{I}))}{1-k/3} + 4$ e o lema segue.
\end{proof}

\begin{theorem}\label{theorem:VWZUZNOR}
O Algoritmo~\ref{algorithm:NTMUPIXY} é uma $\frac{2-k}{1-k/3}$-aproximação assintótica para o problema \SbPRT{} em instâncias clássicas com sinais e para uma proporção $k \in [0..1]$.
\end{theorem}
\begin{proof}
Pelo Lema~\ref{lemma:THMUHLVK} e Teorema~\ref{theorem:WSTPPSMD}, a sequência de operações $S$ obtida através do Algoritmo~\ref{algorithm:NTMUPIXY} satisfaz as seguintes condições: $\pi \cdot S = \iota$, $\frac{|S_{\rho}|}{|S|} \ge k$ e $|S| \le (n+1-c(G(\mathcal{I}))) / (1-k/3) + 4 \le \frac{2-k}{1-k/3} dp_k(\mathcal{I}) + 4$. Logo, o teorema segue.
\end{proof}

% ------------------------------------------------------------------ %
\section{Resultados Práticos}
% ------------------------------------------------------------------ %

Nesta seção, apresentamos os experimentos práticos e os resultados obtidos. Inicialmente, descrevemos os algoritmos utilizados como \emph{baseline}, bem como as modificações realizadas para garantir que suas soluções sejam válidas para o problema \SbPRT{}, ou seja, para garantir que a restrição de propoção seja satisfeita. Em seguida, apresentamos as bases de dados desenvolvidas e utilizadas como entrada pelos algoritmos. Por fim, discutimos os resultados.

% ------------------------------------------------------------------ %
\subsection{Algoritmos Comparados}\label{subsection:BBECOZCK}
% ------------------------------------------------------------------ %

Para fins de comparação, usamos seis algoritmos da literatura como baselines para comparar com os resultados fornecidos por nossos algoritmos. Os algoritmos que descreveremos a seguir foram desenvolvidos para problemas específicos que não consideram a restrição de proporção entre os eventos de rearranjo e podem fornecer soluções inviáveis para o problema \SbPRT{}. Para garantir que todas as soluções sejam viáveis, quando necessário, ajustamos a sequência de eventos de rearranjo substituindo transposições por reversões para atingir a proporção mínima dada como entrada. A seguir, apresentamos os algoritmos de baseline e o processo de modificações realizado.

\begin{itemize}
    \item Instâncias clássicas sem sinais:
    \begin{itemize}
        \item UR: Algoritmo de aproximação com fator $2$ para o problema de Ordenação de Permutações por Reversões~\cite{1995-kececioglu-sankoff}.
        \item UT: Algoritmo de aproximação com fator $1.5$ para o problema de Ordenação de Permutações por Transposições~\cite{1998-bafna-pevzner}.
        \item URT: Algoritmo de aproximação com fator $2\alpha$ para o problema de Ordenação de Permutações por Reversões e Transposições~\cite{2008-rahman-etal}, onde $\alpha$ é o fator de aproximação do algoritmo utilizado para a decomposição de ciclos do Grafo de Ciclos (valor adotado $\alpha = 1.4193 + \epsilon$~\cite{2004-lin-jiang}).
    \end{itemize}
    \item Instâncias clássicas com sinais:
    \begin{itemize}
        \item SR: Algoritmo exato e polinomial para o problema de Ordenação de Permutações por Reversões~\cite{1999-hannenhalli-pevzner}.
        \item SRT: Algoritmo de aproximação com fator $2$ para o problema de Ordenação de permutações por Reversões e Transposições~\cite{1998-walter-etal}.
        \item SWRT: Algoritmo de aproximação com fator $1.5$ para o problema de Ordenação de Permutações por Reversões e Transposições Ponderadas~\cite{2019a-oliveira-etal} (adotando os pesos 2 e 3 para os eventos de reversão e transposição, respectivamente).
    \end{itemize}
\end{itemize}

O processo de modificação realizado na sequência de eventos de rearranjo para satisfazer a restrição de proporção mínima difere entre instâncias clássicas com e sem sinais. No caso de uma instância clássica com sinais, enquanto a proporção mínima não for atingida, uma transposição é substituída por uma sequência de três reversões seguindo o processo descito na Observação~\ref{remark:DNLEDNKT}. No caso de uma instância clássica sem sinais, esse processo segue regras para evitar o crescimento desnecessário da sequência $S$ gerada pelos algoritmo de baseline: (i) se houver uma transposição $\tau^{(i, j, k)}$ tal que $k - i = 2$, então a substituição é realizada apenas por uma reversão $\rho^{(i, k - 1)}$; (ii) se houver uma transposição $\tau^{(i, j, k)}$ tal que $j - i = 1$ ou $k - j = 1$, então a substituição é realizada por uma sequência de duas reversões $S=(\rho^{(i, k - 1)},\rho^{(i, k - 2)})$ ou $S=(\rho^{(i, k - 1)},\rho^{(i + 1, k - 1)}$; e caso contrário, (iii) uma transposição é substituída por uma sequência de três reversões seguindo o processo descito na Observação~\ref{remark:DNLEDNKT}. Este processo se repete enquanto a proporção mínima não é atingida, seguindo a ordem das regras de substituição.

% ------------------------------------------------------------------ %
\subsection{Base de Dados}
% ------------------------------------------------------------------ %

Para verificar o desempenho dos algoritmos em diferentes cenários, criamos bases de dados de instâncias clássicas para simular cenários com proporções fixas entre eventos de reversão e transposição.

DB1 - Esta base de dados é dividida em grupos. Cada grupo tem um total de 10.000 instâncias clássicas de tamanho 200 (ou seja, $\pi$ e $\iota$ tem 200 elementos cada) e é identificado pela proporção $k$ adotada para criar as instâncias. Uma sequência com 40 operações é gerada de forma que seja composta por $40k$ de reversões e $40(1-k)$ de transposições. Os parâmetros das reversões e transposições geradas são escolhidos aleatoriamente entre os valores possíveis. Em seguida, a sequência de operações é embaralhada e aplicada na permutação identidade $\iota$. A permutação resultante $\pi$, a permutação identidade $\iota$ e a proporção $k$ formam uma instância do grupo. Este processo é repetido até que o grupo tenha um total de 10.000 instâncias. As proporções utilizadas variaram de 0 a 1, em intervalos de 0.1, totalizando 11 grupos. Esta base de dados tem as versões com instâncias clássicas com e sem sinais. Considerando instâncias clássicas com e sem sinais, essa base de dados possui um total de 220.000 instâncias.

DB2 - Esta base de dados foi desenvolvido para refletir cenários onde o número de reversões é 50\% maior que o número de transposições. Assim, no processo de criação das instâncias, foi mantida uma proporção de $k = 0,6$. A base de dados é dividida em grupos com 10.000 instâncias cada. Além disso, o identificador do grupo indica o tamanho das instâncias contidas nele e o número de operações utilizadas para criar as instâncias. Os tamanhos usados para as instâncias foram 100, 200, 300, 400 e 500. O número de operações foi baseado em uma porcentagem do tamanho da instância, adotamos: 10\%, 20\%, 30\%, 40\% e 50\%. As etapas finais do processo são semelhantes ao que descrevemos anteriormente na base de dados DB1. Esta base de dados possui uma versão apenas para instâncias clássicas com sinais e um total de 250.000 instâncias.

% ------------------------------------------------------------------ %
\subsection{Comparação dos Algoritmos}
% ------------------------------------------------------------------ %

Nesta seção, apresentamos os resultados fornecidos pelos algoritmos utilizando as bases de dados DB1 e DB2. Nas tabelas~\ref{table:AELVTSMQ}, \ref{table:CLTLBDUJ}, \ref{table:GZLFZWZB} e \ref{table:YDCKQRVK}, as colunas Min, Avg e Max representam mínimo, média e máximo, respectivamente.

O objetivo principal dos testes experimentais é a análise do desempenho prático dos algoritmos propostos comparando-os com as aproximações teóricas e com resultados fornecidos por outros algoritmos da literatura. As tabelas~\ref{table:AELVTSMQ} e~\ref{table:CLTLBDUJ} mostram os resultados dos algoritmos considerando diferentes cenários de proporção, o que é útil para estudar o comportamento dos algoritmos variando a proporção desejada. As siglas UPRT e SPRT referem-se aos algoritmos~\ref{algorithm:INBRWKCH} e~\ref{algorithm:TNMWZNZU}, respectivamente.

A Tabela~\ref{table:AELVTSMQ} mostra os resultados dos algoritmos UR, UT, URT e UPRT aplicados em instâncias sem sinal da base de dados DB1. Algumas soluções fornecidas por UT e URT foram modificadas seguindo o processo descrito na Seção~\ref{subsection:BBECOZCK} para ajustar a proporção mínima entre a quantidade de reversões e tamanho da sequência de rearranjo. Considerando todas as instâncias da base de dados, um total de 90.90\% e 34.39\% das soluções fornecidas por UT e URT, respectivamente, foram modificadas. A razão de aproximação foi calculada adotando-se o limite inferior apresentado no Teorema~\ref{theorem:KJXGKJIP}.

\input{tables/AELVTSMQ}

Pela Tabela~\ref{table:AELVTSMQ}, podemos ver que UR apresenta uma razão média de aproximação maior em valores menores de $k$. No entanto, à medida que o valor de $k$ aumenta, a razão de aproximação média tende a diminuir. A partir dos resultados práticos de UR, é possível notar que a razão de aproximação média é muitas vezes melhor do que o fator de aproximação teórica $3-k$ provado para o problema (Teorema~\ref{theorem:FTRSGXOZ}).

Analisando os resultados fornecidos por UT, é possível notar um comportamento oposto ao de UR, com a razão de aproximação média aumentando à medida que o valor de $k$ aumenta. A razão de aproximação média foi menor que três apenas nos grupos em que $k$ é menor ou igual a 0.2, e a razão de aproximação média no grupo em que $k = 1$ foi de 6.71. Vale ressaltar que todas as soluções fornecidas pela UT para grupos em que $0.1 \le k \le 1.0$ foram modificadas para se adequarem à proporção mínima exigida pelo problema \SbPRT.

Considerando os grupos onde $k \ge 0.7$, a distância máxima fornecida por UT foi supeior a cinco vezes o número de eventos utilizados para criar as instâncias (40 operações). Isso indica que a técnica de modificação de solução aplicada ao algoritmo desenvolvido para o problema considerando apenas transposições não fornece bons resultados para valores maiores de $k$.

Considerando os resultados de URT, podemos observar que a razão média de aproximação foi menor ou igual a 1.96 para todos os grupos. Comparado com UR e UT, o algoritmo URT apresentou melhores resultados para a aproximação média para grupos onde $0.0 < k < 1.0$. Os algoritmos UR e UT apresentaram melhores resultados quando $k = 1,0$ e $k = 0,0$, respectivamente. O desempenho superior de UR e UT nesses cenários particulares ocorre porque a sequência de ordenação composta apenas por reversões se encaixa perfeitamente no caso em que $k = 1,0$ e, quando $k = 0,0$, uma sequência de transposições não precisa passar o processo de modificação para respeitar a restrição de proporção. Nesse caso, modificar as soluções para se adequarem à proporção mínima exigida pela instância resultou em bons resultados independente do grupo.

Observando os resultados do algoritmo UPRT, podemos ver que a razão de aproximação média tende a diminuir à medida que o valor de $k$ aumenta e, em comparação com os demais algoritmos, sofre menor variação. Considerando a maior e a menor taxa de aproximação média entre todos os grupos, temos 1.56 e 1.24, respectivamente. Esta é uma variação de 0.32, o que mostra que o algoritmo é robusto independente da proporção adotada para o cenário. Observe que a variação da aproximação média mostra o quanto o algoritmo oscila de acordo com as diferentes proporções. Deseja-se obter uma variação tão pequena quanto possível. Isso ajuda a obter resultados práticos estáveis, independentemente da proporção desejada. A razão de aproximação média fornecida pelo algoritmo foi melhor que as demais, exceto no grupo onde $k = 0,0$. Isso provavelmente ocorre porque quando $k = 0,0$, uma sequência composta exclusivamente por transposições se enquadra na restrição de proporção. Considerando a razão de aproximação máxima (pior caso prático), podemos observar que em todos os grupos o valor foi menor ou igual a 1.94. Outra característica interessante dos resultados desse algoritmo está relacionada às proporções obtidas nas soluções. A proporção média para todos os grupos é sempre muito próxima do valor mínimo especificado para a instância.

A Tabela~\ref{table:CLTLBDUJ} mostra os resultados dos algoritmos SR, SRT, SWRT e SPRT aplicados em instâncias clássicas com sinais da base de dados DB1. Considerando todas as instâncias da base de dados, um total de 3.65\% e 39.11\% das soluções fornecidas por SRT e SWRT, respectivamente, foram modificadas para se adequarem à proporção mínima entre a quantidade de reversões e tamanho da sequência de rearranjo. A razão de aproximação foi calculada adotando-se o limite inferior apresentado no Teorema~\ref{theorem:WSTPPSMD}.

\input{tables/CLTLBDUJ}

Pela Tabela~\ref{table:CLTLBDUJ}, podemos ver que o algoritmo SR apresentou um comportamento semelhante ao algoritmo UR no caso sem sinal. No entanto, a aproximação média obtida foi exatamente $2 - k$, exceto para o grupo com $k = 0,0$. Observe que quando $k=1$, temos o problema de Ordenando de Permutações por Reversões e, o algoritmo SR fornece uma solução exata em tempo polinomial para o problema. Mantivemos esse cenário de proporção em nossos experimentos para verificar o desempenho dos outros algoritmos neste caso específico.

Os algoritmos SRT e SWRT não apresentam tendência de aumentar ou diminuir a razão média de aproximação considerando o valor de $k$. Comparando ambos, podemos ver que a variação média de aproximação do algoritmo SRT ($1.88 - 1.05 = 0.83$) é maior que a variação do algoritmo SWRT ($1.19 - 1.03 = 0.16$). Em comparação com o SWRT, a proporção média de soluções fornecidas pelo algoritmo SRT é maior. Exceto para o grupo com $k = 0.0$, a proporção média foi superior a $0.97$. O fato do algoritmo SRT não ter aplicado nenhuma reversão no grupo em que $k = 0$ é explicado pelo próprio comportamento do algoritmo, pois ele aplica reversões apenas em ciclos divergentes, e as instâncias desses grupos foram geradas usando apenas transposições, o que não gera ciclos divergentes.

O algoritmo SPRT apresentou a aproximação média mais consistente para os diferentes valores de $k$. Observe que a aproximação média nos extremos quando $k$ é igual a $0,0$ e $1,0$ foi $1.02$ e $1.01$, respectivamente. Além disso, a máxima aproximação média para os diferentes valores de $k$ foi de $1.17$, mostrando a robustez do algoritmo considerando diferentes cenários de proporção.

As tabelas~\ref{table:GZLFZWZB} e \ref{table:YDCKQRVK} mostram, respectivamente, os resultados dos algoritmos SWRT e SPRT considerando o cenário de proporção específico onde $k=0.6$. Como o algoritmo SWRT adota pesos 2 e 3 para eventos de reversão e transposição, respectivamente, uma forma indireta de fornecer uma comparação justa é usar a proporção $k=0.6$ (o número de reversões em uma solução para o problema \SbPRT{} é pelo menos 50\% maior que o número de transposições).

A Tabela~\ref{table:GZLFZWZB} mostra os resultados do algoritmo SWRT aplicado em instâncias clássicas com sinais da base de dados DB2. A coluna OP mostra o número de operações para criar as instâncias. Considerando os grupos de instâncias de tamanho 100, 200, 300, 400 e 500, um total de 37.00\%, 69.46\%, 79.98\%, 84.81\% e 87.59\% das soluções fornecidas pelo algoritmo SWRT foram modificadas, respectivamente. Considerando todas as instâncias, um total de 71.76\% das soluções fornecidas pelo algoritmo SWRT foram modificadas. A razão de aproximação foi calculada adotando-se o limite inferior apresentado no Teorema~\ref{theorem:WSTPPSMD}.

\input{tables/GZLFZWZB}

Pela Tabela~\ref{table:GZLFZWZB}, é possível notar que a variação da razão de aproximação média é muito pequena independente do tamanho da permutação ou do número de operações utilizadas para criar a instância. Considerando a maior e a menor razão de aproximação média, temos os valores $1.12$ e $1.03$, respectivamente. Além disso, a razão de aproximação máxima foi de $1.70$, observada no grupo de instâncias com tamanho 100. Note que o algoritmo apresenta bons resultados mesmo com 71.76\% das instâncias sendo modificadas para satisfazer a restrição de proporção mínima. Isso mostra que o processo de modificação pode produzir bons resultados dependendo do algoritmo utilizado.


A Tabela~\ref{table:YDCKQRVK} mostra os resultados do algoritmo SPRT aplicado aplicado em instâncias clássicas com sinais da base de dados DB2. A coluna OP mostra o número de operações para criar as instâncias. A razão de aproximação foi calculada adotando-se o limite inferior apresentado no Teorema~\ref{theorem:WSTPPSMD}.

\input{tables/YDCKQRVK}

A partir da Tabela~\ref{table:YDCKQRVK}, é possível notar que o algoritmo SPRT apresenta uma tendência de diminuir a razão de aproximação média linearmente à medida que o tamanho da permutação e o número de operações utilizadas para criar as instâncias (OP) crescem. Outro fato importante é que em todos os grupos (considerando o tamanho da instância e o número de operações utilizadas para criar as instâncias), o algoritmo SPRT conseguiu encontrar, para pelo menos uma instância do grupo, uma solução ótima. Podemos confirmar esse comportamento observando a coluna da razão de aproximação mínima. Além disso, considerando os grupos de instâncias com tamanho maior que 100 e os casos em que foram utilizadas sequências de operações maiores que 20\% do tamanho das instâncias, o algoritmo SPRT, em comparação com o algoritmo SWRT, apresentou equivalente ou melhores resultados ao observar a razão de aproximação média.

A partir dos resultados, observamos que os algoritmos propostos apresentam um excelente desempenho na prática, tanto na variação sem sinais do problema \SbPRT, como também na variação com sinais. Vale ressaltar que o processo de modificação da solução proposto para viabilizar soluções obtidas atráves de algoritmo para outros problemas também apresentou bons resultados, principalmente quando aplicado ao algoritmo SWRT.

% ------------------------------------------------------------------ %
\section{Conclusões}
% ------------------------------------------------------------------ %

Neste capítulo, investigamos o problema de Ordenção de Permutações por Reversões e Transposições com Restrição de Proporção. Como resultado, apresentamos uma análise de complexidade do problema para qualquer valor permitido de $k$ e considerando as variações com e sem sinais. Apresentamos algoritmos de aproximação com fatores $3 - \frac{3k}{2}$ e $3-k$ para as variações com e sem sinais, respectivamente. Além disso, apresentamos um algoritmo de aproximação assintótico com fator $\frac{2-k}{1-k/3}$ para a variação com sinais do problema. Por fim, realizamos testes experimentais comparando os algoritmos propostos com outros algoritmo da literatura que fornecem uma solução válida para o problema ou que a solução foi modificada para tornar a comparação possível.